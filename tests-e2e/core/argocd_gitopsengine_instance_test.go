package core

import (
	"context"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/redhat-appstudio/managed-gitops/backend-shared/db"
	"github.com/redhat-appstudio/managed-gitops/backend/util"
	"github.com/redhat-appstudio/managed-gitops/tests-e2e/fixture"
	"github.com/redhat-appstudio/managed-gitops/tests-e2e/fixture/k8s"
	apps "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

var _ = Describe("ArgoCD instance via GitOpsEngineInstance Operations Test", func() {

	const (
		argocdNamespace = fixture.NewArgoCDInstanceNamespace
	)

	Context("ArgoCD instance gets created from an operation's gitopsEngineInstance resource-type", func() {

		BeforeEach(func() {
			By("Delete old namespaces, and kube-system resources")
			Expect(fixture.EnsureCleanSlate()).To(Succeed())

		})

		It("ensures that a standalone ArgoCD gets created successfully when an operation CR of resource-type GitOpsEngineInstance is created", func() {
			err := unsafeCleanDBWhereIDisAutoGenerated()
			Expect(err).To(BeNil())
			if fixture.IsRunningAgainstKCP() {
				Skip("Skipping this test until we support running gitops operator with KCP")
			}

			dbq, err := db.NewUnsafePostgresDBQueries(true, true)
			Expect(err).To(BeNil())
			defer dbq.CloseDatabase()
			err = db.SetupForTestingDBGinkgo()
			Expect(err).To(BeNil())

			k8sClient, err := fixture.GetE2ETestUserWorkspaceKubeClient()
			Expect(err).To(Succeed())

			testClusterUser := &db.ClusterUser{
				Clusteruser_id: "test-user",
				User_name:      "test-user",
			}
			ctx := context.Background()
			log := log.FromContext(ctx)

			By("Creating gitopsengine cluster,cluster user and namespace")

			newArgoCDNamespace := &corev1.Namespace{
				ObjectMeta: metav1.ObjectMeta{
					Name: argocdNamespace,
				},
			}
			err = k8sClient.Create(ctx, newArgoCDNamespace)
			Expect(err).To(BeNil())

			err = util.CreateNewArgoCDInstance(ctx, newArgoCDNamespace, *testClusterUser, k8sClient, log, dbq)
			Expect(err).To(BeNil())

			By("ensuring ArgoCD service resource exists")
			argocdInstance := &apps.Deployment{
				ObjectMeta: metav1.ObjectMeta{Name: newArgoCDNamespace.Name + "-server", Namespace: newArgoCDNamespace.Name},
			}

			Eventually(argocdInstance, "10m", "5s").Should(k8s.ExistByName(k8sClient), "Argo CD server Deployment should exist")
			err = unsafeCleanDBWhereIDisAutoGenerated()
			Expect(err).To(BeNil())

		})
	})
})

func unsafeCleanDBWhereIDisAutoGenerated() error {
	ctx := context.Background()

	// 'testSetup' deletes all database rows that might interfere with ArgoCD setup into a namespace
	// that the OperationCR of resource_type GitopsEngineInstance point to.
	// This ensures a clean slate for the test run.

	dbq, err := db.NewUnsafePostgresDBQueries(true, true)
	Expect(err).To(BeNil())

	defer dbq.CloseDatabase()
	var clusterAccess []db.ClusterAccess
	err = dbq.UnsafeListAllClusterAccess(ctx, &clusterAccess)
	Expect(err).To(BeNil())

	for _, clusterAccess := range clusterAccess {
		if clusterAccess.SeqID >= 0 {
			_, err := dbq.DeleteClusterAccessById(ctx, clusterAccess.Clusteraccess_user_id,
				clusterAccess.Clusteraccess_managed_environment_id,
				clusterAccess.Clusteraccess_gitops_engine_instance_id)
			Expect(err).To(BeNil())

		}
	}

	// Create a list of gitops engine instance uids that were created by test cases; we
	// will later use this to delete old Operations rows, that reference these instances.
	gitopsEngineInstanceUIDsToDelete := map[string]any{}
	{
		var engineInstances []db.GitopsEngineInstance
		err = dbq.UnsafeListAllGitopsEngineInstances(ctx, &engineInstances)
		Expect(err).To(BeNil())
		for _, gitopsEngineInstance := range engineInstances {
			if gitopsEngineInstance.SeqID >= 0 {
				gitopsEngineInstanceUIDsToDelete[gitopsEngineInstance.Gitopsengineinstance_id] = ""
			}

		}
	}

	var operations []db.Operation
	err = dbq.UnsafeListAllOperations(ctx, &operations)
	Expect(err).To(BeNil())

	for _, operation := range operations {

		// Clean up any operations that reference GitOpsEngineInstance that are going to be deleted below.
		_, instanceToBeDeleted := gitopsEngineInstanceUIDsToDelete[operation.Instance_id]

		if instanceToBeDeleted {
			_, err := dbq.CheckedDeleteOperationById(ctx, operation.Operation_id, operation.Operation_owner_user_id)
			Expect(err).To(BeNil())
			_, err = dbq.DeleteGitopsEngineInstanceById(ctx, operation.Instance_id)
			Expect(err).To(BeNil())

		}
	}

	return nil
}
